---
title: Leetcode 03/17/2020
date: 2020-03-17 21:47:09
tags: 
    - LeetCode
categories: LeetCode
---

# [3] Longest Substring Without Repeating Characterss

```java
import java.util.Set;

/*
 * @lc app=leetcode id=3 lang=java
 *
 * [3] Longest Substring Without Repeating Characters
 *
 * https://leetcode.com/problems/longest-substring-without-repeating-characters/description/
 *
 * algorithms
 * Medium (29.66%)
 * Likes:    8021
 * Dislikes: 492
 * Total Accepted:    1.4M
 * Total Submissions: 4.6M
 * Testcase Example:  '"abcabcbb"'
 *
 * Given a string, find the length of the longest substring without repeating
 * characters.
 * 
 * 
 * Example 1:
 * 
 * 
 * Input: "abcabcbb"
 * Output: 3 
 * Explanation: The answer is "abc", with the length of 3. 
 * 
 * 
 * 
 * Example 2:
 * 
 * 
 * Input: "bbbbb"
 * Output: 1
 * Explanation: The answer is "b", with the length of 1.
 * 
 * 
 * 
 * Example 3:
 * 
 * 
 * Input: "pwwkew"
 * Output: 3
 * Explanation: The answer is "wke", with the length of 3. 
 * ⁠            Note that the answer must be a substring, "pwke" is a
 * subsequence and not a substring.
 * 
 * 
 * 
 * 
 * 
 */

// @lc code=start
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int slow = 0;
        int fast = 0;
        Set<Character> charSet = new HashSet();
        int res = 0;

        if (s == null || s.length() == 0) {
            return res;
        }

        while (fast < s.length()) {
            char fChar = s.charAt(fast);
            if (charSet.contains(fChar)) {
                char sChar = s.charAt(slow);
                charSet.remove(sChar);
                slow++;
            } else {
                charSet.add(fChar);
                res = Math.max(res, fast - slow + 1);
                fast++;
            }
        }

        return res;
    }
}
// @lc code=end

```

# [1382] Balance a Binary Search Tree
```java
import java.util.List;
/*
 * @lc app=leetcode id=1382 lang=java
 *
 * [1382] Balance a Binary Search Tree
 *
 * https://leetcode.com/problems/balance-a-binary-search-tree/description/
 *
 * algorithms
 * Medium (74.37%)
 * Likes:    62
 * Dislikes: 12
 * Total Accepted:    6K
 * Total Submissions: 8K
 * Testcase Example:  '[1,null,2,null,3,null,4,null,null]'
 *
 * Given a binary search tree, return a balanced binary search tree with the
 * same node values.
 * 
 * A binary search tree is balanced if and only if the depth of the two
 * subtrees of every node never differ by more than 1.
 * 
 * If there is more than one answer, return any of them.
 * 
 * 
 * Example 1:
 * 
 * 
 * 
 * 
 * Input: root = [1,null,2,null,3,null,4,null,null]
 * Output: [2,1,3,null,null,null,4]
 * Explanation: This is not the only correct answer, [3,1,4,null,2,null,null]
 * is also correct.
 * 
 * 
 * 
 * Constraints:
 * 
 * 
 * The number of nodes in the tree is between 1 and 10^4.
 * The tree nodes will have distinct values between 1 and 10^5.
 * 
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

/**
 * 1. traverse the tree, in-order 2. rebuild the tree
 */
class Solution {
    List<Integer> inOrderList = new ArrayList();

    public TreeNode balanceBST(TreeNode root) {
        inOrderTraverseNode(root);
        return buildBalancedTree(0, inOrderList.size() - 1);
    }

    public void inOrderTraverseNode(TreeNode current) {
        if (current == null) {
            return;
        }
        inOrderTraverseNode(current.left);
        inOrderList.add(current.val);
        inOrderTraverseNode(current.right);
    }

    public TreeNode buildBalancedTree(int start, int end) {
        if (start > end) {
            return null;
        }
        int mid = start + ( end - start ) / 2;
        // Note that (start + end) / 2 might cause some integer overflow issue
        TreeNode currentNode = new TreeNode(inOrderList.get(mid));
        currentNode.left = buildBalancedTree(start, mid - 1);
        currentNode.right = buildBalancedTree(mid + 1, end);
        return currentNode;
    }
}
// @lc code=end

```


